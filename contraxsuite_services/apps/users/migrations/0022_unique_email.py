# Generated by Django 2.2.13 on 2020-10-14 04:47
import uuid
from typing import Tuple, List, Dict

import regex as re
from django.db import migrations, connection, models


class UserData:
    def __init__(self,
                 id: int,
                 email: str,
                 name: str,
                 username: str,
                 emails: List[Tuple[str, bool]] = None,
                 has_social: bool = False):
        self.id = id
        self.email = email.strip()
        self.name = name
        self.username = username
        self.emails: List[Tuple[str, bool]] = emails or []
        self.has_social = has_social
        # email - priority
        # the highest priority have emails taken from "emails" with primary=True flag
        self.email_candidates: List[Tuple[str, int]] = []

    @classmethod
    def make_random_email(cls) -> str:
        return f'{uuid.uuid4()}@local'.lower()


# this pattern obliges having first level domain in email
# REG_EMAIL = re.compile('^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$')
REG_EMAIL = re.compile('^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]{3,255})$')


def is_valid_email(email: str) -> bool:
    return REG_EMAIL.match(email) is not None


def ensure_emails(_apps, _schema_editor):
    with connection.cursor() as cursor:
        users = list(read_users_data(cursor).values())
        # first - users with social accounts
        # if there are duplicates of user email address the user with social account
        # will rather retain his email
        users.sort(key=lambda u: u.has_social, reverse=True)
        occupied_emails = set()
        for user in users:
            email = user.email.lower()
            if email in occupied_emails:
                user.email = ''
            else:
                occupied_emails.add(email)

        fill_email_candidates(users)

        users = [u for u in users if not u.email or not u.email]

        user_email_candidates: List[Tuple[UserData, Tuple[str, int]]] = []
        for u in users:
            for mail_candidate in u.email_candidates:
                user_email_candidates.append((u, mail_candidate))
            # the last option is an auto-generated email
            user_email_candidates.append((u, (UserData.make_random_email(), 0,)))

        user_email_candidates.sort(key=lambda mc: mc[1][1], reverse=True)
        for user, mc in user_email_candidates:
            if user.email:
                continue
            if mc[0] in occupied_emails:
                continue
            user.email = mc[0]

        # now all users should have emails
        for user in users:
            cursor.execute('''update users_user set email = %s where id = %s''',
                           [user.email, user.id])


def fill_email_candidates(users):
    for user in users:
        if user.email:
            continue
        # try email list
        user.emails.sort(key=lambda e: e[0], reverse=True)
        for mail, is_prim in user.emails:
            priority = 100
            if is_prim:
                priority += 200
            user.email_candidates.append((mail, priority,))

        for usr_email_opt in [user.name, user.username]:
            usr_email = (usr_email_opt or '').strip()
            if usr_email and is_valid_email(usr_email):
                user.email_candidates.append((usr_email.lower(), 50,))
        if user.has_social:
            for i in range(len(user.email_candidates)):
                user.email_candidates[i] = (user.email_candidates[i][0].lower(),
                                            user.email_candidates[i][1] + 100,)
        # let email candidates with higher priority go first
        user.email_candidates.sort(key=lambda c: c[1], reverse=True)


def read_users_data(cursor) -> Dict[int, UserData]:
    users: Dict[int, UserData] = {}
    cursor.execute('''select id, email, name, username from users_user;''')
    for id, email, name, username in cursor.fetchall():
        users[id] = UserData(id, email, name, username)
    cursor.execute('''select user_id, email, "primary" from account_emailaddress;''')
    for user_id, email, primary in cursor.fetchall():
        user = users[user_id]
        user.emails.append((email, primary,))
    cursor.execute('''select user_id from socialaccount_socialaccount;''')
    for row in cursor.fetchall():
        users[row[0]].has_social = True
    return users


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0021_auto_20201224_1533'),
    ]

    operations = [
        migrations.RunPython(ensure_emails, reverse_code=migrations.RunPython.noop),
        migrations.AlterField(
            model_name='user',
            name='email',
            field=models.EmailField(max_length=254, unique=True, verbose_name='email address'),
        ),
    ]
