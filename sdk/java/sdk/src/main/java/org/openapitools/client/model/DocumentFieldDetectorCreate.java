/*
 * Contraxsuite API
 * Contraxsuite API
 *
 * The version of the OpenAPI document: 2.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.UUID;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * DocumentFieldDetectorCreate
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-06-16T11:43:26.677726+03:00[Europe/Moscow]")
public class DocumentFieldDetectorCreate {
  public static final String SERIALIZED_NAME_UID = "uid";
  @SerializedName(SERIALIZED_NAME_UID)
  private UUID uid;

  public static final String SERIALIZED_NAME_WARNING_MESSAGE = "warning_message";
  @SerializedName(SERIALIZED_NAME_WARNING_MESSAGE)
  private String warningMessage;

  /**
   * Field detector category used for technical needs e.g. for determining  which field detectors were created automatically during import process.
   */
  @JsonAdapter(CategoryEnum.Adapter.class)
  public enum CategoryEnum {
    SIMPLE_CONFIG("simple_config");

    private String value;

    CategoryEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CategoryEnum fromValue(String value) {
      for (CategoryEnum b : CategoryEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<CategoryEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CategoryEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CategoryEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CategoryEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private CategoryEnum category;

  public static final String SERIALIZED_NAME_EXCLUDE_REGEXPS = "exclude_regexps";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_REGEXPS)
  private String excludeRegexps;

  public static final String SERIALIZED_NAME_DEFINITION_WORDS = "definition_words";
  @SerializedName(SERIALIZED_NAME_DEFINITION_WORDS)
  private String definitionWords;

  public static final String SERIALIZED_NAME_INCLUDE_REGEXPS = "include_regexps";
  @SerializedName(SERIALIZED_NAME_INCLUDE_REGEXPS)
  private String includeRegexps;

  public static final String SERIALIZED_NAME_REGEXPS_PRE_PROCESS_LOWER = "regexps_pre_process_lower";
  @SerializedName(SERIALIZED_NAME_REGEXPS_PRE_PROCESS_LOWER)
  private Boolean regexpsPreProcessLower;

  public static final String SERIALIZED_NAME_DETECTED_VALUE = "detected_value";
  @SerializedName(SERIALIZED_NAME_DETECTED_VALUE)
  private String detectedValue;

  /**
   * Provide additional instruction on which  specific values should be prioritized for extraction, when multiple values of the same type  (e.g., Company, Person, Geography) are found within the relevant detected Text Unit.
   */
  @JsonAdapter(ExtractionHintEnum.Adapter.class)
  public enum ExtractionHintEnum {
    FIRST("TAKE_FIRST"),
    
    SECOND("TAKE_SECOND"),
    
    LAST("TAKE_LAST"),
    
    MIN("TAKE_MIN"),
    
    MAX("TAKE_MAX");

    private String value;

    ExtractionHintEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExtractionHintEnum fromValue(String value) {
      for (ExtractionHintEnum b : ExtractionHintEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ExtractionHintEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExtractionHintEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExtractionHintEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExtractionHintEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_EXTRACTION_HINT = "extraction_hint";
  @SerializedName(SERIALIZED_NAME_EXTRACTION_HINT)
  private ExtractionHintEnum extractionHint;

  /**
   * Defines which part of the matched Text Unit  should be passed to the extraction function. Example: In the string \&quot;2019-01-23 is the start date and 2019-01-24 is the  end date,\&quot; if text part &#x3D; \&quot;Before matching substring\&quot; and Include regexp is \&quot;is.{0,100}start\&quot; then \&quot;2019-01-23\&quot; will be  parsed correctly as the start date.
   */
  @JsonAdapter(TextPartEnum.Adapter.class)
  public enum TextPartEnum {
    FULL("FULL"),
    
    BEFORE_REGEXP("BEFORE_REGEXP"),
    
    AFTER_REGEXP("AFTER_REGEXP"),
    
    INSIDE_REGEXP("INSIDE_REGEXP");

    private String value;

    TextPartEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TextPartEnum fromValue(String value) {
      for (TextPartEnum b : TextPartEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TextPartEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TextPartEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TextPartEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TextPartEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_TEXT_PART = "text_part";
  @SerializedName(SERIALIZED_NAME_TEXT_PART)
  private TextPartEnum textPart;

  /**
   * Choose to add an upward limit to the amount of document text                                               ContraxSuite will search for this Document Field. For example, you can choose                                               to only search the first 10 paragraphs of text for the value required (this                                               often works best for values like “Company,” “Execution Date,” or “Parties,”                                              all of which typically appear in the first few paragraphs of a contract).
   */
  @JsonAdapter(DetectLimitUnitEnum.Adapter.class)
  public enum DetectLimitUnitEnum {
    NONE("NONE"),
    
    UNIT("UNIT");

    private String value;

    DetectLimitUnitEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DetectLimitUnitEnum fromValue(String value) {
      for (DetectLimitUnitEnum b : DetectLimitUnitEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DetectLimitUnitEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DetectLimitUnitEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DetectLimitUnitEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DetectLimitUnitEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_DETECT_LIMIT_UNIT = "detect_limit_unit";
  @SerializedName(SERIALIZED_NAME_DETECT_LIMIT_UNIT)
  private DetectLimitUnitEnum detectLimitUnit;

  public static final String SERIALIZED_NAME_DETECT_LIMIT_COUNT = "detect_limit_count";
  @SerializedName(SERIALIZED_NAME_DETECT_LIMIT_COUNT)
  private Integer detectLimitCount;

  public static final String SERIALIZED_NAME_FIELD = "field";
  @SerializedName(SERIALIZED_NAME_FIELD)
  private String field;

  public DocumentFieldDetectorCreate() { 
  }

  
  public DocumentFieldDetectorCreate(
     UUID uid, 
     String warningMessage
  ) {
    this();
    this.uid = uid;
    this.warningMessage = warningMessage;
  }

   /**
   * Get uid
   * @return uid
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public UUID getUid() {
    return uid;
  }




   /**
   * Get warningMessage
   * @return warningMessage
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public String getWarningMessage() {
    return warningMessage;
  }




  public DocumentFieldDetectorCreate category(CategoryEnum category) {
    
    this.category = category;
    return this;
  }

   /**
   * Field detector category used for technical needs e.g. for determining  which field detectors were created automatically during import process.
   * @return category
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Field detector category used for technical needs e.g. for determining  which field detectors were created automatically during import process.")

  public CategoryEnum getCategory() {
    return category;
  }


  public void setCategory(CategoryEnum category) {
    this.category = category;
  }


  public DocumentFieldDetectorCreate excludeRegexps(String excludeRegexps) {
    
    this.excludeRegexps = excludeRegexps;
    return this;
  }

   /**
   * Enter regular expressions, each on a new line, for text patterns  you want EXCLUDED. The Field Detector will attempt to skip any Text Unit that contains any of the patterns written  here, and will move on to the next Text Unit. Avoid using “.*” and similar unlimited multipliers, as they can crash  or slow ContraxSuite. Use bounded multipliers for variable length matching, like “.{0,100}” or similar. Note that  Exclude regexps are checked before Definition words and Include regexps. If a Field Detector has Exclude regexps, but  no Definition words or Include regexps, it will not extract any data.
   * @return excludeRegexps
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Enter regular expressions, each on a new line, for text patterns  you want EXCLUDED. The Field Detector will attempt to skip any Text Unit that contains any of the patterns written  here, and will move on to the next Text Unit. Avoid using “.*” and similar unlimited multipliers, as they can crash  or slow ContraxSuite. Use bounded multipliers for variable length matching, like “.{0,100}” or similar. Note that  Exclude regexps are checked before Definition words and Include regexps. If a Field Detector has Exclude regexps, but  no Definition words or Include regexps, it will not extract any data.")

  public String getExcludeRegexps() {
    return excludeRegexps;
  }


  public void setExcludeRegexps(String excludeRegexps) {
    this.excludeRegexps = excludeRegexps;
  }


  public DocumentFieldDetectorCreate definitionWords(String definitionWords) {
    
    this.definitionWords = definitionWords;
    return this;
  }

   /**
   * Enter words or phrases, each on a new line, that must be present  in the Text Unit. These words must be in the Definitions List. If ContraxSuite fails to recognize these words as  definitions, then the Field Detector skips and moves to the next Text Unit. If there are Include regexps, then the  Field Detector checks against those requirements. The Field Detector marks the entire Text Unit as a match. Note that  the Field Detector checks for definition words after filtering using the Exclude regexps.
   * @return definitionWords
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Enter words or phrases, each on a new line, that must be present  in the Text Unit. These words must be in the Definitions List. If ContraxSuite fails to recognize these words as  definitions, then the Field Detector skips and moves to the next Text Unit. If there are Include regexps, then the  Field Detector checks against those requirements. The Field Detector marks the entire Text Unit as a match. Note that  the Field Detector checks for definition words after filtering using the Exclude regexps.")

  public String getDefinitionWords() {
    return definitionWords;
  }


  public void setDefinitionWords(String definitionWords) {
    this.definitionWords = definitionWords;
  }


  public DocumentFieldDetectorCreate includeRegexps(String includeRegexps) {
    
    this.includeRegexps = includeRegexps;
    return this;
  }

   /**
   * Enter regular expressions, each on a new  line, for text patterns you want INCLUDED. The Field Detector will attempt to match each of these regular expressions  within a given Text Unit. Avoid using “.*” and similar unlimited multipliers, as they can crash or slow ContraxSuite.  Use bounded multipliers for variable length matching, like “.{0,100}” or similar. Note that Include regexps are checked  after both Exclude regexps and Definition words.
   * @return includeRegexps
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Enter regular expressions, each on a new  line, for text patterns you want INCLUDED. The Field Detector will attempt to match each of these regular expressions  within a given Text Unit. Avoid using “.*” and similar unlimited multipliers, as they can crash or slow ContraxSuite.  Use bounded multipliers for variable length matching, like “.{0,100}” or similar. Note that Include regexps are checked  after both Exclude regexps and Definition words.")

  public String getIncludeRegexps() {
    return includeRegexps;
  }


  public void setIncludeRegexps(String includeRegexps) {
    this.includeRegexps = includeRegexps;
  }


  public DocumentFieldDetectorCreate regexpsPreProcessLower(Boolean regexpsPreProcessLower) {
    
    this.regexpsPreProcessLower = regexpsPreProcessLower;
    return this;
  }

   /**
   * Set &#39;ignore case&#39; flag for both &#39;Include regexps&#39; and &#39;Exclude regexps&#39; options.
   * @return regexpsPreProcessLower
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Set 'ignore case' flag for both 'Include regexps' and 'Exclude regexps' options.")

  public Boolean getRegexpsPreProcessLower() {
    return regexpsPreProcessLower;
  }


  public void setRegexpsPreProcessLower(Boolean regexpsPreProcessLower) {
    this.regexpsPreProcessLower = regexpsPreProcessLower;
  }


  public DocumentFieldDetectorCreate detectedValue(String detectedValue) {
    
    this.detectedValue = detectedValue;
    return this;
  }

   /**
   * The string value written here  will be assigned to the field if the Field Detector positively matches a Text Unit. This is only applicable to Choice,  Multichoice, and String fields, as their respective Field Detectors do not extract and display values from the source  text.
   * @return detectedValue
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The string value written here  will be assigned to the field if the Field Detector positively matches a Text Unit. This is only applicable to Choice,  Multichoice, and String fields, as their respective Field Detectors do not extract and display values from the source  text.")

  public String getDetectedValue() {
    return detectedValue;
  }


  public void setDetectedValue(String detectedValue) {
    this.detectedValue = detectedValue;
  }


  public DocumentFieldDetectorCreate extractionHint(ExtractionHintEnum extractionHint) {
    
    this.extractionHint = extractionHint;
    return this;
  }

   /**
   * Provide additional instruction on which  specific values should be prioritized for extraction, when multiple values of the same type  (e.g., Company, Person, Geography) are found within the relevant detected Text Unit.
   * @return extractionHint
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Provide additional instruction on which  specific values should be prioritized for extraction, when multiple values of the same type  (e.g., Company, Person, Geography) are found within the relevant detected Text Unit.")

  public ExtractionHintEnum getExtractionHint() {
    return extractionHint;
  }


  public void setExtractionHint(ExtractionHintEnum extractionHint) {
    this.extractionHint = extractionHint;
  }


  public DocumentFieldDetectorCreate textPart(TextPartEnum textPart) {
    
    this.textPart = textPart;
    return this;
  }

   /**
   * Defines which part of the matched Text Unit  should be passed to the extraction function. Example: In the string \&quot;2019-01-23 is the start date and 2019-01-24 is the  end date,\&quot; if text part &#x3D; \&quot;Before matching substring\&quot; and Include regexp is \&quot;is.{0,100}start\&quot; then \&quot;2019-01-23\&quot; will be  parsed correctly as the start date.
   * @return textPart
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Defines which part of the matched Text Unit  should be passed to the extraction function. Example: In the string \"2019-01-23 is the start date and 2019-01-24 is the  end date,\" if text part = \"Before matching substring\" and Include regexp is \"is.{0,100}start\" then \"2019-01-23\" will be  parsed correctly as the start date.")

  public TextPartEnum getTextPart() {
    return textPart;
  }


  public void setTextPart(TextPartEnum textPart) {
    this.textPart = textPart;
  }


  public DocumentFieldDetectorCreate detectLimitUnit(DetectLimitUnitEnum detectLimitUnit) {
    
    this.detectLimitUnit = detectLimitUnit;
    return this;
  }

   /**
   * Choose to add an upward limit to the amount of document text                                               ContraxSuite will search for this Document Field. For example, you can choose                                               to only search the first 10 paragraphs of text for the value required (this                                               often works best for values like “Company,” “Execution Date,” or “Parties,”                                              all of which typically appear in the first few paragraphs of a contract).
   * @return detectLimitUnit
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Choose to add an upward limit to the amount of document text                                               ContraxSuite will search for this Document Field. For example, you can choose                                               to only search the first 10 paragraphs of text for the value required (this                                               often works best for values like “Company,” “Execution Date,” or “Parties,”                                              all of which typically appear in the first few paragraphs of a contract).")

  public DetectLimitUnitEnum getDetectLimitUnit() {
    return detectLimitUnit;
  }


  public void setDetectLimitUnit(DetectLimitUnitEnum detectLimitUnit) {
    this.detectLimitUnit = detectLimitUnit;
  }


  public DocumentFieldDetectorCreate detectLimitCount(Integer detectLimitCount) {
    
    this.detectLimitCount = detectLimitCount;
    return this;
  }

   /**
   * Specify the maximum      range for a bounded search. Field detection begins at the top of the document and continues until this Nth      \&quot;Detect limit unit\&quot; element.
   * minimum: -2147483648
   * maximum: 2147483647
   * @return detectLimitCount
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Specify the maximum      range for a bounded search. Field detection begins at the top of the document and continues until this Nth      \"Detect limit unit\" element.")

  public Integer getDetectLimitCount() {
    return detectLimitCount;
  }


  public void setDetectLimitCount(Integer detectLimitCount) {
    this.detectLimitCount = detectLimitCount;
  }


  public DocumentFieldDetectorCreate field(String field) {
    
    this.field = field;
    return this;
  }

   /**
   * Get field
   * @return field
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "")

  public String getField() {
    return field;
  }


  public void setField(String field) {
    this.field = field;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentFieldDetectorCreate documentFieldDetectorCreate = (DocumentFieldDetectorCreate) o;
    return Objects.equals(this.uid, documentFieldDetectorCreate.uid) &&
        Objects.equals(this.warningMessage, documentFieldDetectorCreate.warningMessage) &&
        Objects.equals(this.category, documentFieldDetectorCreate.category) &&
        Objects.equals(this.excludeRegexps, documentFieldDetectorCreate.excludeRegexps) &&
        Objects.equals(this.definitionWords, documentFieldDetectorCreate.definitionWords) &&
        Objects.equals(this.includeRegexps, documentFieldDetectorCreate.includeRegexps) &&
        Objects.equals(this.regexpsPreProcessLower, documentFieldDetectorCreate.regexpsPreProcessLower) &&
        Objects.equals(this.detectedValue, documentFieldDetectorCreate.detectedValue) &&
        Objects.equals(this.extractionHint, documentFieldDetectorCreate.extractionHint) &&
        Objects.equals(this.textPart, documentFieldDetectorCreate.textPart) &&
        Objects.equals(this.detectLimitUnit, documentFieldDetectorCreate.detectLimitUnit) &&
        Objects.equals(this.detectLimitCount, documentFieldDetectorCreate.detectLimitCount) &&
        Objects.equals(this.field, documentFieldDetectorCreate.field);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(uid, warningMessage, category, excludeRegexps, definitionWords, includeRegexps, regexpsPreProcessLower, detectedValue, extractionHint, textPart, detectLimitUnit, detectLimitCount, field);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentFieldDetectorCreate {\n");
    sb.append("    uid: ").append(toIndentedString(uid)).append("\n");
    sb.append("    warningMessage: ").append(toIndentedString(warningMessage)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    excludeRegexps: ").append(toIndentedString(excludeRegexps)).append("\n");
    sb.append("    definitionWords: ").append(toIndentedString(definitionWords)).append("\n");
    sb.append("    includeRegexps: ").append(toIndentedString(includeRegexps)).append("\n");
    sb.append("    regexpsPreProcessLower: ").append(toIndentedString(regexpsPreProcessLower)).append("\n");
    sb.append("    detectedValue: ").append(toIndentedString(detectedValue)).append("\n");
    sb.append("    extractionHint: ").append(toIndentedString(extractionHint)).append("\n");
    sb.append("    textPart: ").append(toIndentedString(textPart)).append("\n");
    sb.append("    detectLimitUnit: ").append(toIndentedString(detectLimitUnit)).append("\n");
    sb.append("    detectLimitCount: ").append(toIndentedString(detectLimitCount)).append("\n");
    sb.append("    field: ").append(toIndentedString(field)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("uid");
    openapiFields.add("warning_message");
    openapiFields.add("category");
    openapiFields.add("exclude_regexps");
    openapiFields.add("definition_words");
    openapiFields.add("include_regexps");
    openapiFields.add("regexps_pre_process_lower");
    openapiFields.add("detected_value");
    openapiFields.add("extraction_hint");
    openapiFields.add("text_part");
    openapiFields.add("detect_limit_unit");
    openapiFields.add("detect_limit_count");
    openapiFields.add("field");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("text_part");
    openapiRequiredFields.add("detect_limit_unit");
    openapiRequiredFields.add("detect_limit_count");
    openapiRequiredFields.add("field");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DocumentFieldDetectorCreate
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (DocumentFieldDetectorCreate.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in DocumentFieldDetectorCreate is not found in the empty JSON string", DocumentFieldDetectorCreate.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DocumentFieldDetectorCreate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DocumentFieldDetectorCreate` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DocumentFieldDetectorCreate.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (jsonObj.get("uid") != null && !jsonObj.get("uid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uid").toString()));
      }
      if (jsonObj.get("warning_message") != null && !jsonObj.get("warning_message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `warning_message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("warning_message").toString()));
      }
      if (jsonObj.get("category") != null && !jsonObj.get("category").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be a primitive type in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      if (jsonObj.get("exclude_regexps") != null && !jsonObj.get("exclude_regexps").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `exclude_regexps` to be a primitive type in the JSON string but got `%s`", jsonObj.get("exclude_regexps").toString()));
      }
      if (jsonObj.get("definition_words") != null && !jsonObj.get("definition_words").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `definition_words` to be a primitive type in the JSON string but got `%s`", jsonObj.get("definition_words").toString()));
      }
      if (jsonObj.get("include_regexps") != null && !jsonObj.get("include_regexps").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `include_regexps` to be a primitive type in the JSON string but got `%s`", jsonObj.get("include_regexps").toString()));
      }
      if (jsonObj.get("detected_value") != null && !jsonObj.get("detected_value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `detected_value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("detected_value").toString()));
      }
      if (jsonObj.get("extraction_hint") != null && !jsonObj.get("extraction_hint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `extraction_hint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("extraction_hint").toString()));
      }
      if (jsonObj.get("text_part") != null && !jsonObj.get("text_part").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `text_part` to be a primitive type in the JSON string but got `%s`", jsonObj.get("text_part").toString()));
      }
      if (jsonObj.get("detect_limit_unit") != null && !jsonObj.get("detect_limit_unit").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `detect_limit_unit` to be a primitive type in the JSON string but got `%s`", jsonObj.get("detect_limit_unit").toString()));
      }
      if (jsonObj.get("field") != null && !jsonObj.get("field").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `field` to be a primitive type in the JSON string but got `%s`", jsonObj.get("field").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DocumentFieldDetectorCreate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DocumentFieldDetectorCreate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DocumentFieldDetectorCreate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DocumentFieldDetectorCreate.class));

       return (TypeAdapter<T>) new TypeAdapter<DocumentFieldDetectorCreate>() {
           @Override
           public void write(JsonWriter out, DocumentFieldDetectorCreate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DocumentFieldDetectorCreate read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DocumentFieldDetectorCreate given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DocumentFieldDetectorCreate
  * @throws IOException if the JSON string is invalid with respect to DocumentFieldDetectorCreate
  */
  public static DocumentFieldDetectorCreate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DocumentFieldDetectorCreate.class);
  }

 /**
  * Convert an instance of DocumentFieldDetectorCreate to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

